// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	"dagger/pipeline/internal/dagger"
	"dagger/pipeline/internal/querybuilder"
	"dagger/pipeline/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Pipeline) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *Pipeline) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r MultiArchContainers) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Containers []*dagger.Container
		Platforms  []dagger.Platform
	}
	concrete.Containers = r.Containers
	concrete.Platforms = r.Platforms
	return json.Marshal(&concrete)
}

func (r *MultiArchContainers) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Containers []*dagger.Container
		Platforms  []dagger.Platform
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Containers = concrete.Containers
	r.Platforms = concrete.Platforms
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func convertError(rerr error) *dagger.Error {
	var gqlErr *gqlerror.Error
	if errors.As(rerr, &gqlErr) {
		dagErr := dag.Error(gqlErr.Message)
		if gqlErr.Extensions != nil {
			keys := make([]string, 0, len(gqlErr.Extensions))
			for k := range gqlErr.Extensions {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				val, err := json.Marshal(gqlErr.Extensions[k])
				if err != nil {
					fmt.Println("failed to marshal error value:", err)
				}
				dagErr = dagErr.WithValue(k, dagger.JSON(val))
			}
		}
		return dagErr
	}
	return dag.Error(rerr.Error())
}

func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, convertError(rerr)); err != nil {
				fmt.Println("failed to return error:", err, "\noriginal error:", rerr)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		var exec *dagger.ExecError
		if errors.As(err, &exec) {
			return exec.Unwrap()
		}
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Pipeline":
		switch fnName {
		case "UnitTests":
			var parent Pipeline
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var sourceDir *dagger.Directory
			if inputArgs["sourceDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["sourceDir"]), &sourceDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg sourceDir", err))
				}
			}
			return (*Pipeline).UnitTests(&parent, ctx, sourceDir)
		case "PushImage":
			var parent Pipeline
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var container *dagger.Container
			if inputArgs["container"] != nil {
				err = json.Unmarshal([]byte(inputArgs["container"]), &container)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg container", err))
				}
			}
			var registryAddress string
			if inputArgs["registryAddress"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registryAddress"]), &registryAddress)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registryAddress", err))
				}
			}
			var imageName string
			if inputArgs["imageName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["imageName"]), &imageName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg imageName", err))
				}
			}
			var tag string
			if inputArgs["tag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tag"]), &tag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tag", err))
				}
			}
			var username string
			if inputArgs["username"] != nil {
				err = json.Unmarshal([]byte(inputArgs["username"]), &username)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg username", err))
				}
			}
			var secret string
			if inputArgs["secret"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secret"]), &secret)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secret", err))
				}
			}
			return (*Pipeline).PushImage(&parent, ctx, container, registryAddress, imageName, tag, username, secret)
		case "BuildImage":
			var parent Pipeline
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var sourceDir *dagger.Directory
			if inputArgs["sourceDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["sourceDir"]), &sourceDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg sourceDir", err))
				}
			}
			return (*Pipeline).BuildImage(&parent, ctx, sourceDir)
		case "BuildMultiArchImage":
			var parent Pipeline
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var sourceDir *dagger.Directory
			if inputArgs["sourceDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["sourceDir"]), &sourceDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg sourceDir", err))
				}
			}
			return (*Pipeline).BuildMultiArchImage(&parent, ctx, sourceDir)
		case "CI":
			var parent Pipeline
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var sourceDir *dagger.Directory
			if inputArgs["sourceDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["sourceDir"]), &sourceDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg sourceDir", err))
				}
			}
			var registryAddress string
			if inputArgs["registryAddress"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registryAddress"]), &registryAddress)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registryAddress", err))
				}
			}
			var imageName string
			if inputArgs["imageName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["imageName"]), &imageName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg imageName", err))
				}
			}
			var tag string
			if inputArgs["tag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tag"]), &tag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tag", err))
				}
			}
			var username string
			if inputArgs["username"] != nil {
				err = json.Unmarshal([]byte(inputArgs["username"]), &username)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg username", err))
				}
			}
			var secret string
			if inputArgs["secret"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secret"]), &secret)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secret", err))
				}
			}
			var multiArch bool
			if inputArgs["multiArch"] != nil {
				err = json.Unmarshal([]byte(inputArgs["multiArch"]), &multiArch)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg multiArch", err))
				}
			}
			return (*Pipeline).CI(&parent, sourceDir, registryAddress, imageName, tag, username, secret, multiArch)
		case "PushMultiArchImage":
			var parent Pipeline
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var multiArch *MultiArchContainers
			if inputArgs["multiArch"] != nil {
				err = json.Unmarshal([]byte(inputArgs["multiArch"]), &multiArch)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg multiArch", err))
				}
			}
			var registryAddress string
			if inputArgs["registryAddress"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registryAddress"]), &registryAddress)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registryAddress", err))
				}
			}
			var imageName string
			if inputArgs["imageName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["imageName"]), &imageName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg imageName", err))
				}
			}
			var tag string
			if inputArgs["tag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tag"]), &tag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tag", err))
				}
			}
			var username string
			if inputArgs["username"] != nil {
				err = json.Unmarshal([]byte(inputArgs["username"]), &username)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg username", err))
				}
			}
			var secret string
			if inputArgs["secret"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secret"]), &secret)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secret", err))
				}
			}
			return (*Pipeline).PushMultiArchImage(&parent, ctx, multiArch, registryAddress, imageName, tag, username, secret)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithObject(
				dag.TypeDef().WithObject("Pipeline", dagger.TypeDefWithObjectOpts{SourceMap: dag.SourceMap("main.go", 10, 6)}).
					WithFunction(
						dag.Function("UnitTests",
							dag.TypeDef().WithKind(dagger.TypeDefKindStringKind)).
							WithDescription("UnitTests kör unit tester").
							WithSourceMap(dag.SourceMap("unit-tests.go", 11, 1)).
							WithArg("sourceDir", dag.TypeDef().WithObject("Directory"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("unit-tests.go", 11, 58)})).
					WithFunction(
						dag.Function("PushImage",
							dag.TypeDef().WithKind(dagger.TypeDefKindStringKind)).
							WithDescription("PushImage pushar image till registry").
							WithSourceMap(dag.SourceMap("push-image.go", 11, 1)).
							WithArg("container", dag.TypeDef().WithObject("Container"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-image.go", 11, 58)}).
							WithArg("registryAddress", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-image.go", 11, 87)}).
							WithArg("imageName", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-image.go", 11, 111)}).
							WithArg("tag", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-image.go", 11, 129)}).
							WithArg("username", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-image.go", 11, 141)}).
							WithArg("secret", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-image.go", 11, 158)})).
					WithFunction(
						dag.Function("BuildImage",
							dag.TypeDef().WithObject("Container")).
							WithDescription("BuildImage bygger en Image från Dockerfile eller direkt från källkoden").
							WithSourceMap(dag.SourceMap("build-image.go", 11, 1)).
							WithArg("sourceDir", dag.TypeDef().WithObject("Directory"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("build-image.go", 11, 59)})).
					WithFunction(
						dag.Function("BuildMultiArchImage",
							dag.TypeDef().WithObject("MultiArchContainers")).
							WithDescription("BuildMultiArchImage bygger containers för flera arkitekturer utan att pusha").
							WithSourceMap(dag.SourceMap("build-multi-arch-image.go", 17, 1)).
							WithArg("sourceDir", dag.TypeDef().WithObject("Directory"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("build-multi-arch-image.go", 17, 68)})).
					WithFunction(
						dag.Function("CI",
							dag.TypeDef().WithKind(dagger.TypeDefKindStringKind)).
							WithDescription("CI kör komplett CI-workflow").
							WithSourceMap(dag.SourceMap("main.go", 13, 1)).
							WithArg("sourceDir", dag.TypeDef().WithObject("Directory"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 14, 2)}).
							WithArg("registryAddress", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 15, 2)}).
							WithArg("imageName", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 16, 2)}).
							WithArg("tag", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 17, 2)}).
							WithArg("username", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 18, 2)}).
							WithArg("secret", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 19, 2)}).
							WithArg("multiArch", dag.TypeDef().WithKind(dagger.TypeDefKindBooleanKind), dagger.FunctionWithArgOpts{Description: "🔑 optional med default true", SourceMap: dag.SourceMap("main.go", 20, 2)})).
					WithFunction(
						dag.Function("PushMultiArchImage",
							dag.TypeDef().WithKind(dagger.TypeDefKindStringKind)).
							WithDescription("PushMultiArchImage pushar multi-arch containers till registry").
							WithSourceMap(dag.SourceMap("push-multi-arch-image.go", 11, 1)).
							WithArg("multiArch", dag.TypeDef().WithObject("MultiArchContainers"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-multi-arch-image.go", 11, 67)}).
							WithArg("registryAddress", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-multi-arch-image.go", 11, 99)}).
							WithArg("imageName", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-multi-arch-image.go", 11, 123)}).
							WithArg("tag", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-multi-arch-image.go", 11, 141)}).
							WithArg("username", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-multi-arch-image.go", 11, 153)}).
							WithArg("secret", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("push-multi-arch-image.go", 11, 170)}))).
			WithObject(
				dag.TypeDef().WithObject("MultiArchContainers", dagger.TypeDefWithObjectOpts{Description: "MultiArchContainers håller containers för olika plattformar", SourceMap: dag.SourceMap("build-multi-arch-image.go", 11, 6)}).
					WithField("Containers", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("Container")), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("build-multi-arch-image.go", 12, 2)}).
					WithField("Platforms", dag.TypeDef().WithListOf(dag.TypeDef().WithScalar("Platform")), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("build-multi-arch-image.go", 13, 2)})), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
